"""Base task processor for worker tasks.

This module provides the base task processor for worker tasks.
"""

import logging
import time
import traceback
from abc import ABC, abstractmethod
from typing import Any, Dict

from app.core.constants import TASK_STATUS_COMPLETED, TASK_STATUS_FAILED


class BaseTaskProcessor(ABC):
    """Abstract base class for task processors.

    All task processors should inherit from this class to ensure consistent
    task lifecycle management.
    """

    def __init__(self, task_id: str, user_id: str, message_payload: Dict[str, Any], services: Dict[str, Any]):
        """Initialize the task processor.

        Args:
            task_id: The ID of the task to process
            user_id: The ID of the user who created the task
            message_payload: The payload from the Pub/Sub message
            services: Dictionary of service instances
        """
        self.task_id = task_id
        self.user_id = user_id
        self.payload = message_payload
        self.services = services
        self.logger = logging.getLogger(self.__class__.__name__)  # Processor-specific logger
        self.task_start_time = time.time()
        self.task_service = services["task_service"]

    async def _claim_task(self) -> bool:
        """Attempt to claim the task for processing.

        Returns:
            bool: True if the task was successfully claimed, False otherwise
        """
        claimed_task = await self.task_service.claim_task_if_pending(task_id=self.task_id, user_id=self.user_id)
        if not claimed_task:
            self.logger.info(f"Task {self.task_id} could not be claimed. Skipping.")
            return False
        self.logger.info(f"[WORKER_TIMING] Task {self.task_id}: Claimed and marked as PROCESSING at {time.time():.2f} ({(time.time() - self.task_start_time):.2f}s elapsed)")
        return True

    async def _update_task_failed(self, error_message: str) -> None:
        """Update task status to failed.

        Args:
            error_message: The error message describing why the task failed
        """
        task_fail_time = time.time()
        self.logger.error(f"Task {self.task_id}: {error_message}")
        self.logger.debug(f"Exception traceback: {traceback.format_exc()}")
        self.logger.error(f"[WORKER_TIMING] Task {self.task_id}: FAILED at {task_fail_time:.2f} (Total Duration: {(task_fail_time - self.task_start_time):.2f}s)")
        try:
            await self.task_service.update_task_status(task_id=self.task_id, status=TASK_STATUS_FAILED, error_message=error_message[:1000])  # Truncate long errors
        except Exception as update_err:
            self.logger.error(f"Task {self.task_id}: Error updating task status to FAILED: {str(update_err)}")

    async def _update_task_completed(self, result_id: str) -> None:
        """Update task status to completed.

        Args:
            result_id: The ID of the result generated by the task
        """
        task_end_time = time.time()
        self.logger.info(f"[WORKER_TIMING] Task {self.task_id}: Completed successfully at {task_end_time:.2f} (Total Duration: {(task_end_time - self.task_start_time):.2f}s)")
        await self.task_service.update_task_status(task_id=self.task_id, status=TASK_STATUS_COMPLETED, result_id=result_id)
        self.logger.info(f"Task {self.task_id}: Completed successfully with result {result_id}")

    @abstractmethod
    async def process(self) -> None:
        """Process the task.

        This method must be implemented by each task processor subclass.
        It should contain the main task processing logic.
        """
        pass
