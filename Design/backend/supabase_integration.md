# Supabase Integration for Backend

## Overview

This document outlines the integration of Supabase with the Concept Visualizer backend for data persistence, session management, and image storage.

## Database Schema

The Supabase PostgreSQL database will have the following schema:

```sql
-- Sessions table to track anonymous users
CREATE TABLE sessions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  last_active_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Concepts table
CREATE TABLE concepts (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  session_id UUID REFERENCES sessions(id) NOT NULL,
  logo_description TEXT NOT NULL,
  theme_description TEXT NOT NULL,
  base_image_path TEXT NOT NULL -- Path to image in Supabase Storage
);

-- Color variations table
CREATE TABLE color_variations (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  concept_id UUID REFERENCES concepts(id) NOT NULL,
  palette_name TEXT NOT NULL,
  colors JSONB NOT NULL, -- Array of hex codes
  description TEXT,
  image_path TEXT NOT NULL -- Path to image in Supabase Storage
);

-- Create indexes for performance
CREATE INDEX concepts_session_id_idx ON concepts(session_id);
CREATE INDEX color_variations_concept_id_idx ON color_variations(concept_id);
```

## Storage Configuration

Supabase Storage will be used to store all generated images. We'll use simplified policies with bucket-specific security:

```sql
-- Create storage buckets
-- 1. concept-images: For storing base concept images
-- 2. palette-images: For storing color palette variations

-- Storage access policies for concept-images bucket
-- Allow anyone to read images (for display)
CREATE POLICY "Public Read Access"
ON storage.objects FOR SELECT
USING (bucket_id = 'concept-images');

-- Allow anyone to upload images (security handled at application level)
CREATE POLICY "Public Write Access"
ON storage.objects FOR INSERT
USING (bucket_id = 'concept-images');

-- Similar policies for palette-images bucket
CREATE POLICY "Public Read Access"
ON storage.objects FOR SELECT
USING (bucket_id = 'palette-images');

CREATE POLICY "Public Write Access"
ON storage.objects FOR INSERT
USING (bucket_id = 'palette-images');
```

File naming convention:

- All files will be stored in folders named after the session ID
- Format: `{session_id}/{uuid}.{extension}`
- Example: `123e4567-e89b-12d3-a456-426614174000/9b1deb4d-3b7d-4bad-9bdd-2b0d7b3dcb6d.png`

## Security Approach

Instead of complex Row Level Security (RLS) policies, we'll implement security at the application level:

1. **Session-based filtering**: All database queries filter by session_id
2. **Folder-based isolation**: Files are organized in session-specific folders
3. **Session validation**: All API endpoints validate the session cookie
4. **Data isolation**: Each user can only access their own data through the API

This approach provides robust security without relying on complex RLS policies that might cause issues with the Supabase implementation.

### Storage Implementation Details

The following implementation elements ensure secure and organized storage:

1. **Bucket Structure**: Two separate buckets keep different types of images organized:

   - `concept-images`: For base logo concept images
   - `palette-images`: For color palette variations of concepts

2. **File Organization**:

   - All files are organized in session-specific folders using the pattern `{session_id}/{uuid}.{extension}`
   - This creates natural isolation between different users' files

3. **Upload Process**:

   - Images are first generated via the JigsawStack API
   - Downloaded using `requests.get()`
   - Uploaded to Supabase Storage with appropriate content-type headers
   - The path is stored in the database for later retrieval

4. **Access Pattern**:

   - Images are accessed via public URLs generated by Supabase Storage
   - The `get_image_url` method retrieves these URLs when needed
   - Public read access is enabled for web display while organizing files by session

5. **Palette Variations**:
   - For the MVP, palette variations simply reuse the original image
   - The `apply_color_palette` method uploads these to the `palette-images` bucket
   - In future versions, actual color transformations will be applied to the images

## Database Access Policies

For each table, we'll enable Row Level Security (RLS) with simple policies:

```sql
-- Enable RLS on all tables
ALTER TABLE sessions ENABLE ROW LEVEL SECURITY;
ALTER TABLE concepts ENABLE ROW LEVEL SECURITY;
ALTER TABLE color_variations ENABLE ROW LEVEL SECURITY;

-- Create simple policies for all tables
CREATE POLICY "Basic Access" ON sessions FOR ALL USING (true);
CREATE POLICY "Basic Access" ON concepts FOR ALL USING (true);
CREATE POLICY "Basic Access" ON color_variations FOR ALL USING (true);
```

## Supabase Client

```python
# backend/app/core/supabase.py
from supabase import create_client, Client
from pydantic import BaseSettings
import logging
import uuid
import io
import requests
from PIL import Image
from typing import Optional

class Settings(BaseSettings):
    """Settings for Supabase configuration."""
    supabase_url: str
    supabase_key: str

    class Config:
        env_file = ".env"

class SupabaseClient:
    """Client for interacting with Supabase."""

    def __init__(self, settings: Settings):
        """Initialize Supabase client with configured settings.

        Args:
            settings: Application settings containing Supabase credentials
        """
        self.client = create_client(settings.supabase_url, settings.supabase_key)
        self.logger = logging.getLogger("supabase_client")

    def get_session(self, session_id: str):
        """Get a session by ID.

        Args:
            session_id: UUID of the session to retrieve

        Returns:
            Session data or None if not found
        """
        try:
            result = self.client.table("sessions").select("*").eq("id", session_id).execute()
            return result.data[0] if result.data else None
        except Exception as e:
            self.logger.error(f"Error retrieving session: {e}")
            return None

    def create_session(self):
        """Create a new session.

        Returns:
            New session data with ID
        """
        try:
            result = self.client.table("sessions").insert({}).execute()
            return result.data[0] if result.data else None
        except Exception as e:
            self.logger.error(f"Error creating session: {e}")
            return None

    def update_session_activity(self, session_id: str):
        """Update session's last_active_at timestamp.

        Args:
            session_id: UUID of the session to update

        Returns:
            Updated session data or None on error
        """
        try:
            result = self.client.table("sessions").update(
                {"last_active_at": "now()"}
            ).eq("id", session_id).execute()
            return result.data[0] if result.data else None
        except Exception as e:
            self.logger.error(f"Error updating session activity: {e}")
            return None

    def store_concept(self, concept_data):
        """Store a new concept.

        Args:
            concept_data: Dictionary with concept details

        Returns:
            Created concept data or None on error
        """
        try:
            result = self.client.table("concepts").insert(concept_data).execute()
            return result.data[0] if result.data else None
        except Exception as e:
            self.logger.error(f"Error storing concept: {e}")
            return None

    def store_color_variations(self, variations):
        """Store color variations for a concept.

        Args:
            variations: List of color variation dictionaries

        Returns:
            Created color variation data or None on error
        """
        try:
            result = self.client.table("color_variations").insert(variations).execute()
            return result.data
        except Exception as e:
            self.logger.error(f"Error storing color variations: {e}")
            return None

    def get_recent_concepts(self, session_id: str, limit: int = 10):
        """Get recent concepts for a session.

        Args:
            session_id: UUID of the session
            limit: Maximum number of concepts to return

        Returns:
            List of concepts with their variations
        """
        try:
            # Security: Always filter by session_id to ensure users only see their own data
            result = self.client.table("concepts").select(
                "*, color_variations(*)"
            ).eq("session_id", session_id).order(
                "created_at", desc=True
            ).limit(limit).execute()

            return result.data
        except Exception as e:
            self.logger.error(f"Error retrieving recent concepts: {e}")
            return []

    async def upload_image_from_url(self, image_url: str, bucket: str, session_id: str):
        """Download an image from URL and upload to Supabase Storage.

        Args:
            image_url: URL of the image to download
            bucket: Storage bucket name ('concept-images' or 'palette-images')
            session_id: Session ID for organizing files

        Returns:
            Storage path of the uploaded image or None on error
        """
        try:
            # Download image from URL
            response = requests.get(image_url, timeout=10)
            response.raise_for_status()

            # Generate a unique filename
            file_ext = "png"  # Default extension
            content_type = response.headers.get("Content-Type", "")
            if "jpeg" in content_type or "jpg" in content_type:
                file_ext = "jpg"
            elif "png" in content_type:
                file_ext = "png"

            # Security: Create path with session_id as the first folder segment
            # This ensures data isolation through folder structure
            unique_filename = f"{session_id}/{uuid.uuid4()}.{file_ext}"

            # Upload to Supabase Storage
            result = self.client.storage.from_(bucket).upload(
                path=unique_filename,
                file=response.content,
                file_options={
                    "content-type": content_type or "image/png"
                }
            )

            # Return the storage path
            return unique_filename

        except Exception as e:
            self.logger.error(f"Error uploading image from URL: {e}")
            return None

    def get_image_url(self, path: str, bucket: str):
        """Get the public URL for an image in Supabase Storage.

        Args:
            path: Path of the image in storage
            bucket: Storage bucket name

        Returns:
            Public URL for the image
        """
        try:
            return self.client.storage.from_(bucket).get_public_url(path)
        except Exception as e:
            self.logger.error(f"Error getting image URL: {e}")
            return None

    async def apply_color_palette(self, image_path: str, palette: list, session_id: str):
        """Apply a color palette to an image and store the result.

        This is a basic implementation that would need enhancement for production.
        For MVP, it simply transfers the original image.

        Args:
            image_path: Path of the base image in storage
            palette: List of hex color codes
            session_id: Session ID for organizing files

        Returns:
            Path of the new image with applied palette
        """
        try:
            # For MVP, we'll just copy the original image
            # In a full implementation, we would apply the palette
            original_url = self.get_image_url(image_path, "concept-images")
            if not original_url:
                return None

            # Upload (for now, just the same image) to palette-images bucket
            return await self.upload_image_from_url(
                original_url,
                "palette-images",
                session_id
            )
        except Exception as e:
            self.logger.error(f"Error applying color palette: {e}")
            return None

# Factory function for creating the client
def get_supabase_client(settings: Settings = None):
    """Factory function to get Supabase client.

    Args:
        settings: Optional settings object

    Returns:
        Configured SupabaseClient instance
    """
    if settings is None:
        settings = Settings()
    return SupabaseClient(settings)
```

## Session Management Service

```python
# backend/app/services/session_service.py
from fastapi import Depends, Cookie, Response
from typing import Optional, Tuple
from ..core.supabase import get_supabase_client, SupabaseClient

class SessionService:
    """Service for managing user sessions."""

    def __init__(self, supabase_client: SupabaseClient = Depends(get_supabase_client)):
        """Initialize session service with a Supabase client.

        Args:
            supabase_client: Client for interacting with Supabase
        """
        self.supabase_client = supabase_client

    async def get_or_create_session(
        self,
        response: Response,
        session_id: Optional[str] = Cookie(None, alias="concept_session")
    ) -> Tuple[str, bool]:
        """Get existing session or create a new one.

        Args:
            response: FastAPI response object for setting cookies
            session_id: Optional existing session ID from cookies

        Returns:
            Tuple of (session_id, is_new_session)
        """
        is_new_session = False

        if not session_id:
            # Create new session
            session = self.supabase_client.create_session()
            if session:
                session_id = session["id"]
                is_new_session = True
            else:
                # Fallback to a local UUID if Supabase is unavailable
                import uuid
                session_id = str(uuid.uuid4())
                is_new_session = True
        else:
            # Validate session exists and update last_active_at
            session = self.supabase_client.get_session(session_id)
            if not session:
                # Session ID in cookie doesn't exist in database
                # Create a new session instead
                session = self.supabase_client.create_session()
                if session:
                    session_id = session["id"]
                    is_new_session = True
                else:
                    import uuid
                    session_id = str(uuid.uuid4())
                    is_new_session = True
            else:
                # Update last_active_at for existing session
                self.supabase_client.update_session_activity(session_id)

        # Set session cookie
        response.set_cookie(
            key="concept_session",
            value=session_id,
            httponly=True,
            max_age=60*60*24*30,  # 30 days
            samesite="lax",
            secure=True  # Set to False in development if needed
        )

        return session_id, is_new_session

# Dependency function for FastAPI routes
async def get_session_service(
    supabase_client: SupabaseClient = Depends(get_supabase_client)
) -> SessionService:
    """Factory function for SessionService.

    Args:
        supabase_client: Supabase client dependency

    Returns:
        Configured SessionService instance
    """
    return SessionService(supabase_client)
```

## Image Service

```python
# backend/app/services/image_service.py
from fastapi import Depends
from typing import List, Dict, Optional, Tuple
from ..core.supabase import get_supabase_client, SupabaseClient
from ..core.jigsawstack_client import JigsawStackClient, get_jigsawstack_client

class ImageService:
    """Service for image generation and storage."""

    def __init__(
        self,
        supabase_client: SupabaseClient = Depends(get_supabase_client),
        jigsawstack_client: JigsawStackClient = Depends(get_jigsawstack_client)
    ):
        """Initialize image service with required clients.

        Args:
            supabase_client: Client for Supabase operations
            jigsawstack_client: Client for JigsawStack API
        """
        self.supabase_client = supabase_client
        self.jigsawstack_client = jigsawstack_client

    async def generate_and_store_image(self, prompt: str, session_id: str) -> Tuple[str, str]:
        """Generate an image and store it in Supabase.

        Args:
            prompt: Image generation prompt
            session_id: Current session ID

        Returns:
            Tuple of (storage_path, public_url) or (None, None) on error
        """
        try:
            # Generate image using JigsawStack
            result = await self.jigsawstack_client.generate_image(prompt=prompt)
            if not result or "url" not in result:
                return None, None

            # Download and upload to Supabase Storage
            storage_path = await self.supabase_client.upload_image_from_url(
                result["url"],
                "concept-images",
                session_id
            )

            if not storage_path:
                return None, None

            # Get public URL
            public_url = self.supabase_client.get_image_url(storage_path, "concept-images")

            return storage_path, public_url
        except Exception as e:
            return None, None

    async def create_palette_variations(
        self,
        base_image_path: str,
        palettes: List[Dict],
        session_id: str
    ) -> List[Dict]:
        """Create variations of an image with different color palettes.

        Args:
            base_image_path: Storage path of the base image
            palettes: List of color palette dictionaries
            session_id: Current session ID

        Returns:
            List of palettes with added image_path and image_url fields
        """
        result_palettes = []

        for palette in palettes:
            # Apply palette to image
            palette_image_path = await self.supabase_client.apply_color_palette(
                base_image_path,
                palette["colors"],
                session_id
            )

            if palette_image_path:
                # Get public URL
                palette_image_url = self.supabase_client.get_image_url(
                    palette_image_path,
                    "palette-images"
                )

                # Add paths to palette dict
                palette_copy = palette.copy()
                palette_copy["image_path"] = palette_image_path
                palette_copy["image_url"] = palette_image_url
                result_palettes.append(palette_copy)

        return result_palettes
```

## Concept Storage Service

```python
# backend/app/services/concept_storage_service.py
from fastapi import Depends
from typing import List, Dict, Optional
from ..core.supabase import get_supabase_client, SupabaseClient
from ..models.concept import ColorPalette, ConceptSummary, ConceptDetail

class ConceptStorageService:
    """Service for storing and retrieving concepts."""

    def __init__(self, supabase_client: SupabaseClient = Depends(get_supabase_client)):
        """Initialize concept storage service with a Supabase client.

        Args:
            supabase_client: Client for interacting with Supabase
        """
        self.supabase_client = supabase_client

    async def store_concept(
        self,
        session_id: str,
        logo_description: str,
        theme_description: str,
        base_image_path: str,
        color_palettes: List[Dict]
    ) -> Optional[Dict]:
        """Store a new concept and its color variations.

        Args:
            session_id: Session ID to associate with the concept
            logo_description: User's logo description
            theme_description: User's theme description
            base_image_path: Path to the generated base image in Supabase Storage
            color_palettes: List of color palette dictionaries with image_path fields

        Returns:
            Created concept data or None on error
        """
        # Insert concept
        concept_data = {
            "session_id": session_id,
            "logo_description": logo_description,
            "theme_description": theme_description,
            "base_image_path": base_image_path
        }

        concept = self.supabase_client.store_concept(concept_data)
        if not concept:
            return None

        # Insert color variations
        variations = []
        for palette in color_palettes:
            variation = {
                "concept_id": concept["id"],
                "palette_name": palette["name"],
                "colors": palette["colors"],
                "description": palette.get("description"),
                "image_path": palette["image_path"]  # Path to the palette-specific image in Storage
            }
            variations.append(variation)

        variations_result = self.supabase_client.store_color_variations(variations)

        # Return full concept with variations
        if variations_result:
            concept["color_variations"] = variations_result
            return concept
        return concept

    async def get_recent_concepts(self, session_id: str, limit: int = 10) -> List[ConceptSummary]:
        """Get recent concepts for a session.

        Args:
            session_id: Session ID to get concepts for
            limit: Maximum number of concepts to return

        Returns:
            List of concept summaries with their variations
        """
        concepts = self.supabase_client.get_recent_concepts(session_id, limit)

        # Convert to ConceptSummary model
        summaries = []
        for concept in concepts:
            # Add public URLs for all images
            base_image_url = self.supabase_client.get_image_url(
                concept["base_image_path"],
                "concept-images"
            )

            # Add URLs to color variations
            if "color_variations" in concept:
                for variation in concept["color_variations"]:
                    variation["image_url"] = self.supabase_client.get_image_url(
                        variation["image_path"],
                        "palette-images"
                    )

            concept["base_image_url"] = base_image_url
            summaries.append(self._to_concept_summary(concept))

        return summaries

    async def get_concept_detail(self, concept_id: str) -> Optional[ConceptDetail]:
        """Get detailed information about a specific concept.

        Args:
            concept_id: ID of the concept to retrieve

        Returns:
            Concept detail object or None if not found
        """
        try:
            result = self.supabase_client.client.table("concepts").select(
                "*, color_variations(*)"
            ).eq("id", concept_id).execute()

            if result.data:
                concept = result.data[0]

                # Add public URLs for all images
                base_image_url = self.supabase_client.get_image_url(
                    concept["base_image_path"],
                    "concept-images"
                )

                # Add URLs to color variations
                if "color_variations" in concept:
                    for variation in concept["color_variations"]:
                        variation["image_url"] = self.supabase_client.get_image_url(
                            variation["image_path"],
                            "palette-images"
                        )

                concept["base_image_url"] = base_image_url
                return self._to_concept_detail(concept)
            return None
        except Exception as e:
            self.supabase_client.logger.error(f"Error retrieving concept detail: {e}")
            return None

    def _to_concept_summary(self, concept_data: Dict) -> ConceptSummary:
        """Convert raw concept data to ConceptSummary model.

        Args:
            concept_data: Raw concept data from Supabase

        Returns:
            ConceptSummary object
        """
        # Implementation depends on ConceptSummary model
        pass

    def _to_concept_detail(self, concept_data: Dict) -> ConceptDetail:
        """Convert raw concept data to ConceptDetail model.

        Args:
            concept_data: Raw concept data from Supabase

        Returns:
            ConceptDetail object
        """
        # Implementation depends on ConceptDetail model
        pass

# Dependency function for FastAPI routes
async def get_concept_storage_service(
    supabase_client: SupabaseClient = Depends(get_supabase_client)
) -> ConceptStorageService:
    """Factory function for ConceptStorageService.

    Args:
        supabase_client: Supabase client dependency

    Returns:
        Configured ConceptStorageService instance
    """
    return ConceptStorageService(supabase_client)
```

## API Endpoints

```python
# backend/app/api/routes/concept.py
from fastapi import APIRouter, Depends, Response, Cookie
from typing import Optional, List
from ...models.request import PromptRequest, RefinementRequest
from ...models.response import GenerationResponse
from ...models.concept import ConceptSummary, ConceptDetail
from ...services.concept_service import ConceptService, get_concept_service
from ...services.session_service import SessionService, get_session_service
from ...services.image_service import ImageService, get_image_service
from ...services.concept_storage_service import ConceptStorageService, get_concept_storage_service

router = APIRouter()

@router.post("/generate", response_model=GenerationResponse)
async def generate_concept(
    request: PromptRequest,
    response: Response,
    concept_service: ConceptService = Depends(get_concept_service),
    session_service: SessionService = Depends(get_session_service),
    image_service: ImageService = Depends(get_image_service),
    storage_service: ConceptStorageService = Depends(get_concept_storage_service)
):
    """Generate a concept based on user prompt and store it.

    Args:
        request: User prompt request with logo and theme descriptions
        response: FastAPI response object for setting cookies
        concept_service: Service for generating concepts
        session_service: Service for managing sessions
        storage_service: Service for storing concepts

    Returns:
        Generated concept with image URL and color palettes
    """
    # Get or create session
    session_id, _ = await session_service.get_or_create_session(response)

    # Generate base image and store it in Supabase Storage
    base_image_path, base_image_url = await image_service.generate_and_store_image(
        request.logo_description,
        session_id
    )

    # Generate color palettes
    palettes = await concept_service.generate_color_palettes(request.theme_description)

    # Apply color palettes to create variations and store in Supabase Storage
    palette_variations = await image_service.create_palette_variations(
        base_image_path,
        palettes,
        session_id
    )

    # Store concept in Supabase database
    stored_concept = await storage_service.store_concept(
        session_id=session_id,
        logo_description=request.logo_description,
        theme_description=request.theme_description,
        base_image_path=base_image_path,
        color_palettes=palette_variations
    )

    # Return generation response
    return GenerationResponse(
        prompt_id=stored_concept["id"] if stored_concept else "temp_id",
        image_url=base_image_url,
        color_palettes=[
            {
                "name": p["name"],
                "colors": p["colors"],
                "description": p.get("description"),
                "image_url": p["image_url"]
            }
            for p in palette_variations
        ]
    )

@router.get("/recent", response_model=List[ConceptSummary])
async def get_recent_concepts(
    response: Response,
    session_service: SessionService = Depends(get_session_service),
    storage_service: ConceptStorageService = Depends(get_concept_storage_service),
    session_id: Optional[str] = Cookie(None, alias="concept_session")
):
    """Get recent concepts for the current session."""
    # Get or create session
    session_id, is_new_session = await session_service.get_or_create_session(response, session_id)

    # Return empty list for new sessions
    if is_new_session:
        return []

    # Get recent concepts with public image URLs
    return await storage_service.get_recent_concepts(session_id)

@router.get("/concept/{concept_id}", response_model=ConceptDetail)
async def get_concept_detail(
    concept_id: str,
    storage_service: ConceptStorageService = Depends(get_concept_storage_service)
):
    """Get detailed information about a specific concept."""
    return await storage_service.get_concept_detail(concept_id)
```

## Environment Configuration

The backend will need the following environment variables:

```
SUPABASE_URL=https://your-project-id.supabase.co
SUPABASE_KEY=your-service-role-key or anon key
JIGSAWSTACK_API_KEY=your-jigsawstack-api-key
```

## Dependencies

Ensure the following dependencies are installed:

```bash
uv add supabase
uv add python-multipart  # Required for file handling
uv add pillow  # For image processing
```

## Future Enhancements

1. **Image Processing**:

   - Implement more sophisticated color palette application using PIL
   - Add image optimization for better performance
   - Support different image formats and resolutions

2. **Storage Management**:

   - Implement periodic cleanup of unused images
   - Add caching for frequently accessed images
   - Implement batch operations for bulk image processing

3. **Security**:

   - Enhance RLS policies for finer-grained access control
   - Implement image content validation
   - Add rate limiting for storage operations

4. **Performance**:
   - Optimize image download/upload process
   - Implement background processing for image operations
   - Add image compression for storage efficiency

```

```
